# IBPMデータ解像度戦略の検討

## 現状の問題

現在のワークフロー：
```
IBPM (200×200) → Tecplot出力 (199×199) → 粗視化 (49×49) → 補間 (64×64) → SDA学習
```

**問題点**:
1. 高解像度データを生成してから圧縮するのは非効率
2. 粗視化と補間の2段階処理で情報が劣化する可能性
3. 大量のTecplotファイル（251個 × 2.4MB = 約600MB）が中間生成される

---

## グリッド解像度と物理的妥当性の分析

### 現状（200×200）

```
計算領域: 4.0 × 4.0 (円柱直径の4倍)
グリッド解像度: 200×200
格子幅: dx = dy = 0.02
円柱直径: D = 1.0
円柱解像度: 50.0 points/D ✅ (標準的)
CFL数: 1.0 (安定性の限界)
```

### Option 1: 単純にグリッド解像度を下げる（計算領域固定）

| 解像度 | dx | 円柱解像度 | CFL数 | 評価 |
|--------|-----|-----------|-------|------|
| **200×200** | 0.0200 | 50.0 points/D | 1.00 | ⭐ 現状（標準的） |
| **128×128** | 0.0312 | 32.0 points/D | 0.64 | ⚠️ ギリギリ許容範囲 |
| **64×64** | 0.0625 | 16.0 points/D | 0.32 | ❌ 粗すぎる |

**結論**:
- **64×64は円柱を16点でしか解像できず、物理的に不十分**
- 128×128なら最低限の解像度（32点/D）だが、渦構造の詳細が失われる

---

### Option 2: 計算領域を縮小（グリッド解像度を維持）

| 解像度 | 計算領域 | dx | 円柱解像度 | 領域サイズ | 評価 |
|--------|---------|-----|-----------|-----------|------|
| 64×64 | 1.28 × 1.28 | 0.0200 | 50.0 points/D | 1.3D × 1.3D | ❌ 領域が狭すぎる |
| 64×64 | 2.56 × 2.56 | 0.0400 | 25.0 points/D | 2.6D × 2.6D | ⚠️ 境界の影響大 |
| 64×64 | 4.00 × 4.00 | 0.0625 | 16.0 points/D | 4.0D × 4.0D | ❌ 円柱解像度不足 |

**IBPMコマンド例**:
```bash
# 小さい領域（1.28D × 1.28D）で64×64
ibpm -nx 64 -ny 64 -length 1.28 -xoffset -0.64 -yoffset -0.64 -geom cylinder.geom
```

**結論**:
- **領域を狭めると境界条件の影響が大きくなり、物理的に不正確**
- 円柱後方の渦構造を観測するには最低4D以上の領域が必要

---

### Option 3: 円柱サイズを大きくする（逆転の発想）

| 円柱直径 | dx | 円柱解像度 | Reynolds数維持 | 評価 |
|---------|-----|-----------|---------------|------|
| D = 1.0 | 0.0625 | 16.0 points/D | Re=100, ν=0.01 | ❌ 現状の問題 |
| D = 2.0 | 0.0625 | 32.0 points/D | Re=100, ν=0.02 | ⚠️ 許容範囲 |
| D = 3.0 | 0.0625 | 48.0 points/D | Re=100, ν=0.03 | ✅ 良好 |

**IBPMコマンド例**:
```bash
# 円柱直径3.0の場合
ibpm -nx 64 -ny 64 -length 4.0 -geom cylinder_d3.geom -Re 100
```

**cylinder_d3.geom**:
```
body Cylinder
  circle_n 0 0 1.5 160    # 半径1.5（直径3.0）
end
```

**メリット**:
- 64×64グリッドで十分な円柱解像度（48点/D）を確保
- 計算領域は4×4のまま
- 補間・粗視化が不要

**デメリット**:
- 計算領域が円柱直径の1.3倍になり、境界の影響が増える
- 物理的な意味が変わる（元の条件と異なる系になる）

---

## 選択肢の整理

### 選択肢A: IBPMパラメータのみで対応（外部パッケージとして維持）

#### A-1: 128×128で計算
```bash
ibpm -nx 128 -ny 128 -length 4.0 -geom cylinder.geom -nsteps 1000 -tecplot 1
```

**メリット**:
- IBPMを外部パッケージとして維持できる
- 円柱解像度32点/Dで最低限の精度を確保
- 変換時の補間が少なくて済む（128→64は2倍のダウンサンプリング）

**デメリット**:
- 円柱解像度が現状の50点/Dから32点/Dに低下
- 渦構造の詳細が失われる可能性

**変換処理**:
```python
# 128×128 → 64×64 (2×2ブロック平均)
velocity_64 = block_reduce(velocity_128, (1, 2, 2), func=np.mean)
```

---

#### A-2: 円柱を大きくして64×64で計算
```bash
ibpm -nx 64 -ny 64 -length 4.0 -geom cylinder_d3.geom -Re 100 -nsteps 1000
```

**メリット**:
- IBPMを外部パッケージとして維持
- 補間・粗視化が不要（直接64×64）
- 円柱解像度48点/Dで高精度

**デメリット**:
- 物理条件が変わる（D=3.0は元の条件と異なる）
- 計算領域が1.3D×1.3Dになり境界の影響が大きい
- 学習データとして妥当性に疑問

---

### 選択肢B: IBPMをforkしてカスタマイズ

#### B-1: Tecplot出力を任意解像度で補間出力

**変更箇所**: `/opt/ibpm/src/OutputTecplot.cc`, `ScalarToTecplot.cc`

**実装方針**:
```cpp
// 新オプション: -tecplot_nx, -tecplot_ny を追加
// Tecplot出力時に内部グリッド（例：200×200）から
// 指定解像度（例：64×64）へバイリニア補間して出力

bool OutputTecplot::doOutput(const State& state) {
    // 既存の処理
    Scalar u(state.omega.getGrid());
    Scalar v(state.omega.getGrid());
    FluxToVelocity(state.q, u, v);

    // 新機能：出力グリッドへ補間
    if (_output_nx > 0 && _output_ny > 0) {
        interpolateToOutputGrid(u, v, state.omega);
    }

    // Tecplot出力
    ScalarToTecplot(varVec, varNameVec, filename, title);
}
```

**メリット**:
- 計算精度を維持（内部は200×200で高精度計算）
- 出力データサイズを削減（64×64で出力）
- 後処理の補間・粗視化が不要

**デメリット**:
- IBPMをforkして独自管理が必要
- アップストリームの更新を取り込む手間
- 補間処理の実装が必要

---

#### B-2: 計算グリッドと出力グリッドを分離

**変更箇所**: より大規模な変更（Grid構造の拡張）

**実装方針**:
- 内部計算グリッド（高解像度）と出力グリッド（低解像度）を分離
- より柔軟だが実装コストが高い

**メリット**:
- 完全な制御
- 将来の拡張性が高い

**デメリット**:
- 大規模な変更が必要
- メンテナンスコストが高い
- バグのリスク

---

## 推奨方針

### 第1推奨: **選択肢A-1（128×128で計算）**

```bash
# 1. IBPMを128×128で実行
ibpm -nx 128 -ny 128 -length 4.0 -geom cylinder.geom \
     -nsteps 1000 -tecplot 1 -Re 100 -dt 0.015 \
     -outdir /workspace/data/ibpm_128

# 2. 変換スクリプトで128→64にダウンサンプル
python scripts/convert_ibpm_to_sda.py \
       --input-dir /workspace/data/ibpm_128 \
       --output-dir /workspace/data/ibpm_h5 \
       --target-size 64
```

**理由**:
1. **外部パッケージとして維持**: IBPMのソースコード変更不要
2. **物理的妥当性**: 円柱解像度32点/Dで最低限の精度を確保
3. **シンプルな変換**: 128→64は2倍のダウンサンプリングで実装が簡単
4. **CFL数改善**: dt=0.015にすればCFL=0.48で安定

**変換処理の改良**:
```python
from skimage.measure import block_reduce

# 2×2ブロック平均でダウンサンプル（補間不要）
velocity_64 = block_reduce(velocity_128, block_size=(1, 2, 2), func=np.mean)
```

---

### 第2推奨: **選択肢B-1（Tecplot出力カスタマイズ）**

IBPMを長期的に使う場合、または計算精度を最大化したい場合。

**実装ステップ**:
1. IBPMをfork: `git clone /opt/ibpm /workspace/ibpm-custom`
2. 出力解像度オプションを追加
3. `OutputTecplot.cc`に補間機能を実装
4. ビルドして独自バイナリを作成

**メリット**:
- 計算精度最大（200×200で計算）
- 出力サイズ最小（64×64で出力）
- 後処理不要

**デメリット**:
- 実装コスト（C++でバイリニア補間を実装）
- メンテナンスコスト（独自fork管理）

---

### 第3推奨: **選択肢A-1 + 長期的にB-1へ移行**

**フェーズ1（現在）**:
- 128×128で計算、ダウンサンプルで64×64に変換
- SDA学習の実験を進める

**フェーズ2（必要に応じて）**:
- IBPMをforkして出力カスタマイズ
- より高精度なデータ生成

---

## 実装の難易度評価

| 選択肢 | 実装難易度 | メンテナンス | 物理精度 | データ品質 |
|-------|----------|------------|---------|-----------|
| A-1 (128×128) | ⭐ 簡単 | ⭐⭐⭐ 容易 | ⭐⭐ 許容 | ⭐⭐ 良好 |
| A-2 (大きい円柱) | ⭐ 簡単 | ⭐⭐⭐ 容易 | ⭐ 低い | ⭐ 疑問 |
| B-1 (出力カスタマイズ) | ⭐⭐⭐ 中程度 | ⭐⭐ やや困難 | ⭐⭐⭐ 高い | ⭐⭐⭐ 最高 |
| B-2 (大規模変更) | ⭐⭐⭐⭐⭐ 困難 | ⭐ 困難 | ⭐⭐⭐ 高い | ⭐⭐⭐ 最高 |

---

## IBPMのfork判断基準

### forkすべき場合:
- ✅ IBPMを長期的に使用する予定
- ✅ 最高品質のデータが必要
- ✅ 計算精度を最大化したい
- ✅ C++開発の経験がある
- ✅ 独自機能の追加が必要

### forkすべきでない場合:
- ❌ 短期的な実験のみ
- ❌ データ品質よりスピード重視
- ❌ メンテナンスリソースが限られている
- ❌ C++開発の経験が少ない
- ❌ 既存の変換で十分

---

## 具体的なコマンド例

### 推奨方針A-1の実装

```bash
# 1. IBPMを128×128で実行（CFL数を考慮してdt調整）
cd /workspace
ibpm -nx 128 -ny 128 \
     -length 4.0 -xoffset -2.0 -yoffset -2.0 \
     -geom /opt/ibpm/examples/cylinder.geom \
     -Re 100 -dt 0.015625 \
     -nsteps 320 \
     -tecplot 1 \
     -force 1 \
     -outdir /workspace/data/ibpm_128

# 総時間: 320 × 0.015625 = 5.0 (元と同じ)
# CFL数: 1.0 × 0.015625 / 0.03125 = 0.5 (安定)

# 2. 変換スクリプト実行
python scripts/convert_ibpm_to_sda.py \
       --input-dir /workspace/data/ibpm_128 \
       --output-dir /workspace/data/ibpm_h5 \
       --coarsen-factor 2 \
       --target-size 64
```

---

## まとめ

**推奨**: まず**選択肢A-1（128×128計算）**で実装し、必要に応じて**選択肢B-1（IBPMカスタマイズ）**へ移行

**理由**:
1. 外部パッケージとして維持できる（シンプル）
2. 物理的に妥当な解像度（32点/D）
3. 実装が簡単（パラメータ変更のみ）
4. 将来の拡張性を確保

**次のステップ**:
1. 変換スクリプトを128×128対応に修正
2. 128×128でIBPMを実行
3. データ品質を検証
4. 必要に応じてforkを検討
